<div align="center">

<h1>模式扩展</h1>

</div>

# 目录

- [目录](#目录)
- [概述](#概述)
- [波浪号扩展](#波浪号扩展)
- [问号扩展](#问号扩展)
- [星号扩展](#星号扩展)
- [方括号扩展](#方括号扩展)
- [\[start-end\] 扩展](#start-end-扩展)
- [大括号扩展](#大括号扩展)
- [{start..end} 扩展](#startend-扩展)
- [变量扩展](#变量扩展)


# 概述

Bash 中的模式扩展（globbing）是一种在命令行解释阶段对特殊字符进行扩展的机制，而通配符扩展（wildcard expansion）是模式扩展的一部分，涉及到通配符的使用。

> 小结：模式扩展就是将包含通配符的模式转换为实际文件名或路径的过程。

也就是说，对于一条命令来说，会先对特殊字符进行扩展，再执行命令，并且模式扩展不包括参数，收到什么参数就原样执行。

关闭扩展：

```bash
$ set -o noglob
# 或者
$ set -f
```

开启扩展：

```bash
$ set +o noglob
# 或者
$ set +f
```

# 波浪号扩展

波浪线（~）在 Bash 中有几种特殊的扩展用法，如下所述：

1. **波浪线扩展：** 单独的波浪线（~）会自动扩展成当前用户的主目录。例如，`cd ~` 将切换到当前用户的主目录。

2. **~user 扩展：** 波浪线后跟用户名（例如，`~user`）会扩展成该用户的主目录。如果指定的用户不存在，则波浪线扩展不起作用。

3. **~+ 扩展：** 波浪线后跟加号（+），即`~+`，会扩展成当前所在的目录，等同于 `pwd` 命令的输出。

示例：
```bash
# 波浪线扩展为当前用户的主目录
$ echo ~

# 波浪线扩展为指定用户（如果存在）的主目录
$ echo ~username

# 波浪线扩展为当前目录，等同于 pwd 命令
$ echo ~+
```

# 问号扩展

在模式扩展（globbing）中，问号（`?`）字符用于**匹配文件路径中的任意单个字符**，但**不包括空字符**。

这对于需要模糊匹配文件名中的某些字符的情况很有用。

```bash
# 存在文件 a.txt 和 b.txt
$ ls ?.txt
a.txt b.txt

# 存在文件 a.txt、b.txt 和 ab.txt
$ ls ??.txt
ab.txt
```

# 星号扩展

`*` 扩展用于匹配文件路径中的任意数量的任意字符，包括零个字符。

```bash
# 存在文件 a.txt、b.txt 和 ab.txt
$ ls *.txt
a.txt b.txt ab.txt

$ ls a*.txt
a.txt ab.txt

$ ls *b*
b.txt ab.txt
```

输出当前目录下的所有文件：

```bash
$ ls *
```

在`Linux`系统中，文件名以`.`开头的被认为是隐藏文件。

显示所有隐藏文件：

```bash
$ echo .*
. .. .bash_history .bash_logout .bashrc .cache .config .gnupg .ICEauthority .local .mozilla .profile .ssh .swp .viminfo .Xauthority
```

这里有两个特殊的隐藏目录，分别是`.`和`..`。如果我们在列出所有隐藏文件时，希望排除这两个特殊的目录，那么可以这样：

```bash
$ echo .[!.]*
.bash_history .bash_logout .bashrc .cache .config .gnupg .ICEauthority .local .mozilla .profile .ssh .swp .viminfo .Xauthority
```

`*` 只匹配当前目录，不会匹配子目录。

```bash
# 子目录有一个 a.txt
# 无效的写法
$ ls *.txt

# 有效的写法
$ ls */*.tx
```

# 方括号扩展

`[]`表示一个字符集合，匹配其中的任意一个字符。

比如`[abc]` 匹配单个字符，可以是 `a`、`b` 或 `c` 中的任意一个，但只能匹配一个。

```bash
# 存在文件 a.txt 和 b.txt
$ ls [ab].txt
a.txt b.txt

# 只存在文件 a.txt
$ ls [ab].txt
a.txt
```

`[]`扩展还有另一种用法，即取反匹配。格式是 `[^]`或者`[!]`，这表示匹配任意不在方括号中的字符。比如`[^abc]` 表示匹配任意一个字符，但不是 `a`、`b` 或 `c`。

注意事项：

1. 如果需要匹配`[`字符，可以放在方括号内，比如`[[aeiou]`。
2. 如果需要匹配连字号`-`，只能放在方括号内部的开头或结尾，比如`[-aeiou]`或`[aeiou-]`。

# [start-end] 扩展

`[start-end]` 扩展是方括号扩展的简写形式，表示一个范围。这种形式的扩展允许你表示一个字符集合，其中包含某一范围内的字符。例如，`[a-z]` 表示小写字母 `a` 到 `z`。

常用例子如下：

- `[0-9]`: 匹配任意数字。
- `[a-z]`: 匹配任意小写字母。
- `[A-Z]`: 匹配任意大写字母。
- `[a-zA-Z]`: 匹配任意字母。
- `[!a-zA-Z]`: 匹配非英文字母的字符。
- `[0-9a-f]`: 匹配任意十六进制数字（0-9 和 a-f）。

这种形式的扩展非常有用，因为它允许你用更简洁的方式表示一系列字符，而不必逐个列举。例如，`[0-9]` 可以替代 `0123456789`。

# 大括号扩展

大括号扩展`{...}`表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。

```bash
$ echo d{a,e,i,u,o}g
dag deg dig dug dog
```

如果内部的逗号前后有空格，大括号扩展就会失效。

```bash
$ echo {1 , 2}
{1 , 2}
```

逗号前面如果没有值，表示扩展的第一项为空。

```bash
$ cp a.log{,.bak}

# 等同于
# cp a.log a.log.bak
```

大括号可以嵌套。

```bash
$ echo {j{p,pe}g,png}
jpg jpeg png
```

大括号会先于其他模式进行扩展。

```bash
$ echo /bin/{cat,b*}
/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...

# 基本等同于
$ echo /bin/cat;echo /bin/b*
```

需要注意，由于大括号扩展`{...}`不是文件名扩展，所以它总是会扩展的。这与方括号扩展`[...]`完全不同，大括号扩展总是会扩展的，即使匹配的文件不存在，但方括号则不会扩展。

```bash
$ echo [ab].txt
[ab].txt

$ echo {a,b}.txt
a.txt b.txt
```

# {start..end} 扩展

大括号扩展的简写形式 `{start..end}` 表示扩展成一个连续序列。

```bash
$ echo Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5
```

这种简写形式支持逆序。

```bash
$ echo {5..1}
5 4 3 2 1
```

如果整数前面有前导0，扩展输出的每一项都有前导0。

```bash
$ echo {01..5}
01 02 03 04 05

$ echo {001..5}
001 002 003 004 005
```

还可以指定步长，格式为：`{start..end..step}`。

```bash
$ echo {0..8..2}
0 2 4 6 8
```

连用会有循环处理效果：

```bash
$ echo {a..c}{1..3}
a1 a2 a3 b1 b2 b3 c1 c2 c3
```


# 变量扩展

Bash 将美元符号$开头的词元视为变量，将其扩展成变量值。

```bash
$ echo $SHELL
/bin/bash
# 或者可以这样：
$ echo ${SHELL}
/bin/bash
```

另外，`${!string*}`表示返回所有匹配给定字符串`string`的变量名，`${!string*}` 这种语法用于在Bash中进行**间接引用**，这里的 `*` 通配符表示匹配以 `string` 开头的所有变量名。

