<div align="center">

<h1>Linux编程基础</h1>

</div>

# 目录

- [目录](#目录)
- [vi 或 vim](#vi-或-vim)
  - [工作模式：](#工作模式)
  - [常用命令：](#常用命令)
- [GCC](#gcc)
  - [编译流程](#编译流程)
  - [编译常用选项](#编译常用选项)
  - [GCC指令](#gcc指令)
  - [告警和出错选项](#告警和出错选项)
  - [库依赖](#库依赖)
- [GDB](#gdb)
  - [概述](#概述)
  - [GDB使用流程](#gdb使用流程)
  - [GDB基本命令](#gdb基本命令)
- [Makefile](#makefile)
  - [Make工程管理器](#make工程管理器)
  - [Makefile基本结构](#makefile基本结构)
  - [模式规则](#模式规则)
  - [自动变量](#自动变量)


# vi 或 vim

`vi` 或 `vim` 是一款强大的文本编辑器，常用于Unix和Linux系统。它有三种主要工作模式：命令模式、编辑模式和底行模式。

## 工作模式：

1. **命令模式：**
   - 在此模式下，键盘输入会被解释为命令。你可以执行移动光标、复制、粘贴等操作。

2. **编辑模式：**
   - 在此模式下，你可以输入或编辑文本。按下 `i` 键进入编辑模式。

3. **底行模式：**
   - 在此模式下，你可以保存文件、退出编辑器等。按下 `:` 键进入底行模式。

![image-20231230171125420](images/02-Linux编程基础/image-20231230171125420.png)

## 常用命令：

- **yy：**
  - 复制当前行（在命令模式下输入 `yy`）。

- **dd：**
  - 删除当前行（在命令模式下输入 `dd`）。

- **:q!：**
  - 放弃所有更改并强制退出（在底行模式下输入 `:q!`）。

- **:q：**
  - 退出编辑器（在底行模式下输入 `:q`）。

- **:wq：**
  - 保存更改并退出编辑器（在底行模式下输入 `:wq`）。

---


# GCC

## 编译流程

编译过程通常包括以下四个阶段：

1. **预处理（Preprocessing）：**
   - 展开宏定义，处理条件编译，生成经过预处理的源代码文件（通常以`.i`为扩展名）。

2. **编译（Compilation）：**
   - 将预处理后的代码翻译成汇编代码（通常以`.s`为扩展名）。

3. **汇编（Assembly）：**
   - 将汇编代码翻译成目标机器语言，生成目标文件（通常以`.o`为扩展名）。

4. **链接（Linking）：**
   - 将目标文件与其他目标文件或库文件链接在一起，生成最终的可执行文件。

---


## 编译常用选项

1. **`-o file`：**
   - 指定输出文件的名称，例如 `-o my_program`。

2. **`-g`：**
   - 生成包含调试信息的可执行文件，以便在调试时使用。

3. **`-E`：**
   - 只进行预处理，生成预处理后的代码。

4. **`-S`：**
   - 只进行编译，生成汇编代码。

5. **`-c`：**
   - 只进行编译和汇编，生成目标文件。

6. **`-I dir`：**
   - 指定头文件的搜索路径，例如 `-I /usr/include`。

7. **`-L path`：**
   - 指定库文件的搜索路径，例如 `-L /usr/lib`。

8. **`-lname`：**
   - 指定要链接的库文件，例如 `-lm` 链接数学库。

9. **`-Wall`：**
   - 启用所有常用的警告信息。


## GCC指令

`GCC`指令的一般格式如下：

```bash
gcc [选项] 要编译的文件 [选项] [目标文件]
```

其中：

- `gcc` 是编译命令。
- `[选项]` 包含各种编译选项，例如优化级别、调试信息等。
- `要编译的文件` 是源代码文件的名称。
- `[目标文件]` 是生成的目标文件的名称。

在底层执行过程中，一条 `gcc` 指令包含了多个阶段，每个阶段有不同的责任：

1. **预处理阶段（cpp）**：
   - `cpp` 是预处理器，负责对源代码进行预处理。
   - 在这个阶段，宏会被展开，条件编译会进行，生成一个经过预处理的中间文件（通常以`.i`为扩展名）。
   - 我们可使用 `-E` 选项来查看：
   ```bash
   $ gcc -E hello.c -o hello.i
   ```

2. **编译阶段（ccl）**：
   - `ccl` 表示 C Compiler，这个阶段将预处理后的文件编译成汇编代码。
   - 生成一个汇编代码文件（通常以`.s`为扩展名）。
   - 我们可使用 `-S` 选项来查看：
   ```bash
   $ gcc -S hello.i -o hello.s
   ```

3. **汇编阶段（as）**：
   - `as` 是汇编器，将汇编代码转换成目标文件。
   - 生成一个目标文件（通常以`.o`为扩展名）。
   - 我们可使用 `-c` 选项来查看：
   ```bash
   $ gcc -c hello.s -o hello.o
   ```

4. **链接阶段（ld）**：
   - `ld` 是链接器，负责将多个目标文件和库文件链接在一起，生成最终的可执行文件。
   - 可执行文件的名称可以通过 `-o` 选项指定，如果没有指定，默认为 `a.out`。
   ```bash
   $ gcc hello.o -o hello
   ```

## 告警和出错选项

`gcc` 提供的编译选项中，有一些是用于控制警告和错误的处理。

举例如下：

1. **`-pedantic`**：
   - `-pedantic` 选项启用更多的警告，**包括一些标准之外的语法和语义问题**。
   - 这个选项用于强制编译器严格遵循语言标准，尽量避免使用非标准的语法或行为。
   - 帮助程序员发现一些不符合 ANSI/ISO C标准的代码（但不是全部）。
   - 例如，如果代码中使用了一些标准之外的语法或特性，`-pedantic` 选项将发出相应的警告。
   - 用法：
   ```bash
   $ gcc -pedantic -o output_file source_file.c
   ```

2. **`-Wall`**：
   - `-Wall` 选项**启用大多数常见的警告**。
   - 它用于开启编译器的一般警告，帮助开发者发现潜在的问题或不良实践。
   - 警告可以帮助改善代码的质量和可维护性。
   - 用法：
   ```bash
   $ gcc -Wall -o output_file source_file.c
   ```

3. **`-Werror`**：
   - `-Werror` 选项**将所有警告视为错误**，导致编译过程中任何警告都会被当作错误处理，终止编译过程。
   - 这有助于确保代码在编译时不会产生任何警告，提高代码质量。
   - 如果使用了 `-Werror`，开发者需要确保代码中没有警告，否则编译将失败。
   - 用法：
   ```bash
   $ gcc -Werror -o output_file source_file.c
   ```

## 库依赖

在编写和编译程序时，可能会使用到各种函数库（或称为动态链接库、静态链接库）。这些库通常包括头文件（`.h`）和相应的库文件（`.a` 或者 `.so`）。为了在编译过程中正确地链接这些库，需要告诉编译器它们的位置。这就是库依赖管理的问题。

以下是一些与库依赖相关的概念和使用方法：

1. **头文件的位置**：
   - 头文件通常包含函数和数据结构的声明，但不包含实际的实现。
   - 通常存储在 `/usr/include/` 目录下，但有些库可能存储在其他位置。

2. **库文件的位置**：
   - 库文件包含实际的函数和数据结构的实现。
   - 通常存储在 `/usr/lib/` 或 `/usr/lib64/` 目录下，但也可能存储在其他位置。

3. **查找头文件和库文件**：
   - 使用 `-I` 选项告诉编译器在哪里查找头文件。
   - 使用 `-L` 选项告诉编译器在哪里查找库文件。
   - 使用 `-l` 选项指定要链接的库的名称。

   ```bash
   $ gcc -I/path/to/header/files -L/path/to/library/files -lmylibrary -o output_file source_file.c
   ```

   - 上述命令中，`-I` 用于指定头文件的路径，`-L` 用于指定库文件的路径，`-l` 用于指定要链接的库。注意，库名不需要加上前缀 "lib" 和文件扩展名，例如，使用 `-lmylibrary` 会查找 `libmylibrary.so` 或 `libmylibrary.a`。

---

# GDB

## 概述

GDB（GNU调试器）是一个用于调试程序的强大工具。它能够在程序执行时监视并控制其行为，帮助你找到和修复错误。在使用 `gcc` 编译时，添加 `-g` 选项可以将调试信息嵌入可执行文件中，这样 GDB 就能更好地理解源代码和程序的关系。

## GDB使用流程

以下是使用GDB的基本流程：

1. **在编译时加入调试信息**：

- 在使用GDB进行调试之前，首先确保在编译程序时加入调试信息。
- 通过在编译时添加 `-g` 选项来实现。
- 举例：
```bash
$ gcc -g source_file.c -o executable_file
```

2. **启动GDB**：

- 使用 `gdb` 命令启动GDB，并指定要调试的可执行文件，通常在当前目录下
- 举例：
```bash
$ gdb executable_file
```
- 如果要同时调试运行程序和`core`文件，可以这样：
```bash
# core文件是程序非法执行后core dump产生的
$ gdb executable_file core
```
- 如果要附加到运行中的进程可以这样：
```bash
$ gdb executable_file PID
```
- 此时`executable_file`是服务程序，并且在PATH环境变量中搜索得到，此时指定进程ID，gdb会自动attach上去并调试


3. **GDB命令**：
   - 一旦GDB启动，可以使用各种命令来控制调试过程。一些常用的命令包括：
     - `run`：启动程序并开始调试。
     - `break`：设置断点。
     - `step`：逐行执行程序，进入函数内部。
     - `next`：逐行执行程序，不进入函数内部。
     - `print`：打印变量的值。
     - `backtrace` 或 `bt`：显示函数调用堆栈。
     - `quit`：退出`GDB`。

4. **调试过程**：
   - 在调试过程中，可以使用断点、单步执行、查看变量值等功能，帮助定位和解决程序中的错误。
   - `GDB`还提供了丰富的命令和选项，以满足不同场景下的调试需求。

5. **退出GDB**：
   - 在调试完成后，可以使用 `quit` 命令退出`GDB`。

   ```bash
   (gdb) quit
   ```

## GDB基本命令





---

# Makefile

## Make工程管理器

`Make` 是一个用于构建（build）和管理项目的工具，它最早是为Unix系统设计的，但现在已经在多个平台上得到广泛应用。`Make` 的工作原理是基于一个称为 `Makefile` 的文本文件，`Makefile` 包含了构建规则和依赖关系，告诉 `make` 如何构建项目。

> 注意，`Make` 能够通过根据文件时间戳自动发现更新过的文件，减少不必要的编译工作，从而提高项目的工作效率。

## Makefile基本结构

`Makefile` 的基本结构如下：

```bash
target: dependency_files
    command
```

其中：

- `target` 是目标体。
- `dependency_files` 是要创建目标体所需的依赖文件。
- `command` 是创建每个目标体时需要运行的命令，必须以`Tab`键开始。

示例：

```bash
main: main.c utils.c
    gcc -o main main.c utils.c
```

上述示例中，`main` 是目标体，它依赖于 `main.c` 和 `utils.c`，命令是使用 `gcc` 编译这两个文件生成可执行文件 `main`。

如果你需要清理生成的文件，可以添加一个清理规则，例如：

```bash
clean:
    rm -f target
```

在这个例子中，`clean` 是一个伪目标，它不产生实际的文件，但可以通过执行 `make clean` 命令来删除生成的目标体和依赖文件。

## 模式规则

什么是模式规则。

% 

模式规则可以提高编写Makefile文件的效率，无需手动输入若干条编译条件，类似对号入座进行匹配。


## 自动变量

在 `Makefile` 中，有一些特殊的变量称为自动变量，它们在规则中具有特殊的含义：

- `$*`：不包含扩展名的目标文件名称。
- `$+`：表示所有的依赖文件，以空格分隔，以出现的先后为序，可能包含重复的依赖文件。
- `$<`：表示第一个依赖文件。
- `$?`：所有时间戳比目标文件晚的依赖文件，以空格分隔。
- `$@`：目标文件的完整名称。
- `$^`：所有不重复的依赖文件，以空格分开。
- `$%`：如果目标是归档成员，则该变量表示目标的归档成员名称。